<!doctype html>
<html lang="pt-br">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mapa DWDM — v11-fix (Canvas + anti-wrap)</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<style>
  :root{ --bg:#f6f7fb; --fg:#111; --muted:#374151; --card:#fff; --bd:#e5e7eb; }
  body{margin:0;background:var(--bg);color:var(--fg);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;}
  #map{position:absolute; inset:0}

  .toolbar{position:absolute; z-index:1000; left:12px; top:12px; right:12px; display:flex; gap:10px; flex-wrap:wrap; align-items:center;
           background:var(--card); padding:10px 12px; border:1px solid var(--bd); border-radius:12px; box-shadow:0 6px 30px rgba(0,0,0,.06)}
  .toolbar .group{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .toolbar input[type="text"]{padding:7px 10px; border:1px solid var(--bd); border-radius:10px; min-width:260px}
  .toolbar button,.toolbar label.btn{padding:8px 10px; border:1px solid var(--bd); border-radius:10px; background:#fafafa; cursor:pointer}

  .legend,.legend-clients{position:absolute; right:14px; z-index:1000; background:var(--card); border:1px solid var(--bd); border-radius:10px; padding:8px 10px; color:#374151; font-size:12px}
  .legend{bottom:14px}
  .legend-clients{bottom:140px; max-height:300px; width:290px; overflow:auto}
  .legend .line{display:flex; align-items:center; gap:8px; margin:4px 0}
  .legend .sample{width:42px; height:0; border-top:3px solid #222}
  .legend .dash{border-top-style:dashed}
  .legend .dot{border-top-style:dotted; border-top-width:2px}

  .legend-clients .row{display:flex; align-items:center; gap:8px; padding:4px 0; border-bottom:1px dashed #eee}
  .legend-clients .sw{width:18px; height:12px; border-radius:3px; border:1px solid var(--bd)}
  .legend-clients .row label{display:flex; align-items:center; gap:8px; flex:1; cursor:pointer}

  .credit{position:absolute; left:14px; bottom:14px; z-index:1000; color:#374151; font-size:12px; background:var(--card);
          border:1px solid var(--bd); border-radius:10px; padding:6px 8px}

  .leaflet-control-container .leaflet-top,.leaflet-control-container .leaflet-bottom{z-index:1500}

  .modal{ position:fixed; inset:0; background:rgba(0,0,0,.3); display:none; align-items:center; justify-content:center; z-index:2000; }
  .modal .card{ background:var(--card); border:1px solid var(--bd); border-radius:12px; padding:16px; width:min(760px,96vw); box-shadow:0 10px 40px rgba(0,0,0,.15); }
  .modal .row{ display:flex; gap:10px; margin:8px 0; align-items:center; }
  .modal label{ width:170px; color:#374151; font-size:13px; }
  .modal input, .modal select{ flex:1; padding:8px; border:1px solid var(--bd); border-radius:8px; }

  .pillset{ display:flex; flex-wrap:wrap; gap:6px; }
  .pillset label{ border:1px solid var(--bd); border-radius:999px; padding:6px 10px; cursor:pointer; }
  .pillset input{ display:none; }
  .pillset input:checked + span{ background:#eef2ff; border-color:#c7d2fe; }

  .chips{ display:flex; gap:6px; flex-wrap:wrap; }
  .chip{ background:#eef2ff; border:1px solid #c7d2fe; border-radius:999px; padding:4px 8px; display:inline-flex; align-items:center; gap:6px; }
  .chip button{ border:0; background:transparent; cursor:pointer; font-weight:700; }
</style>
</head>
<body>
  <div id="map"></div>

  <div class="toolbar" id="toolbar">
    <div class="group">
      <button id="btnFetch">Recarregar JSON</button>
      <label class="btn">Carregar JSON <input id="fileJSON" type="file" accept=".json,.json5,.txt" hidden></label>
      <label><input type="checkbox" id="chkDark"> Tema escuro</label>
      <label><input type="checkbox" id="chkPontos" checked> Mostrar pontos</label>
      <button id="btnAdd">Adicionar canal</button>
      <button id="btnExport">Exportar JSON</button>
      <button id="btnPng">Exportar PNG</button>
      <button id="btnPdf">Exportar PDF</button>
      <button id="btnCenterMap">Centralizar</button>
    </div>
    <div class="group" style="margin-left:auto">
      <input id="txtSearch" type="text" placeholder="buscar cliente/canal/cidade/parceiro"/>
      <button id="btnSearch">Buscar</button>
      <button id="btnClear">Limpar</button>
      <label><input type="checkbox" id="tProprio" checked> Próprio</label>
      <label><input type="checkbox" id="tCedido" checked> Cedido</label>
      <label><input type="checkbox" id="tRecebido" checked> Recebido</label>
    </div>
  </div>

  <div class="legend-clients" id="legendClients">
    <b>Clientes no mapa</b>
    <div style="display:flex;gap:8px;margin:6px 0">
      <button id="btnAllClients">Marcar todos</button>
      <button id="btnNoClients">Desmarcar todos</button>
    </div>
    <div id="legendClientsList"></div>
  </div>

  <div class="legend">
    <div class="line"><span class="sample"></span> Próprio — <i>linha contínua</i></div>
    <div class="line"><span class="sample dash"></span> Cedido — <i>linha tracejada</i></div>
    <div class="line"><span class="sample dot"></span> Recebido — <i>linha pontilhada</i></div>
  </div>
  <div class="credit">Afastamento automático nas rotas sobrepostas • Controles de zoom no canto inferior direito</div>

  <!-- (Modais de adicionar/editar/nova cidade — idênticos à versão anterior) -->
  <!-- ... para encurtar esta resposta, deixei os modais exatamente como estavam no seu v11; nada mudou neles ... -->

  <datalist id="citiesList"></datalist>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-image/leaflet-image.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <script>
  (function(){
    /* ===================== CONFIG ===================== */
    const JSON_URL  = 'mapadwdm.json';
    const SHIFT_GAP   = 12;          // afastamento entre rotas paralelas (px)
    const OFFSET_MODE = 'constant';  // 'constant' = offset constante por rota

    /* ===================== VARIÁVEIS ===================== */
    let DATA=null, CITY_COORDS=null, CITY_BOUNDS=null;
    let map, BASE_LIGHT, BASE_DARK, currentBase, CANV;
    let CLIENT_LAYERS={}, HILAYER=null, SELAYER=null, ALL_LINES=[];
    let CLIENT_VISIBLE={};

    const $ = id => document.getElementById(id);

    /* ============ CORES (iguais à versão anterior) ============ */
    // ... (mantenho todas as helpers de cor exatamente como você recebeu no v11)
    // Para economizar espaço, omiti aqui — mas no seu arquivo final essas funções permanecem idênticas:
    // hexToRgb, hslToRgb, rgbToXyz, xyzToLab, rgbToLab, deltaE00, normalizeHex,
    // registerUsedColor, getOrCreateClientColor, USED, MIN_DELTAE
    // -------------- CÓDIGO DE CORES (COLE IGUAL AO DA SUA V11) --------------

    /* ============ PROXIMIDADE / ALT-CLICK ============ */
    // ... (mesmo da v11)
    function pointSegDist(p, a, b){ const abx=b.x-a.x, aby=b.y-a.y, apx=p.x-a.x, apy=p.y-a.y;
      const ab2=abx*abx+aby*aby; let t=ab2? (apx*abx+apy*aby)/ab2 : 0; if(t<0) t=0; else if(t>1) t=1;
      const x=a.x+abx*t, y=a.y+aby*t; return Math.hypot(p.x-x, p.y-y); }
    function routeMinDistPx(rec, latlng){
      const p=map.latLngToLayerPoint(latlng), ll=rec.line.getLatLngs(); let min=Infinity;
      for(let i=0;i<ll.length-1;i++){ const a=map.latLngToLayerPoint(ll[i]), b=map.latLngToLayerPoint(ll[i+1]);
        min=Math.min(min, pointSegDist(p,a,b)); } return min; }
    function showNearbyRoutes(latlng){
      const cand=[]; for(const rec of ALL_LINES){ const d=routeMinDistPx(rec, latlng); if(d<=18) cand.push({rec,d}); }
      if(!cand.length) return false; cand.sort((a,b)=>a.d-b.d);
      const div=document.createElement('div');
      div.innerHTML='<b>Canais próximos</b><br>'+cand.slice(0,10).map((c,i)=>`
        <div style="margin:4px 0; display:flex; gap:6px; align-items:center">
          <span style="width:10px;height:10px;border-radius:50%;background:${c.rec.line.options.color};display:inline-block"></span>
          <button data-i="${i}">selecionar</button>
          <span>${(c.rec.canalRef.id||'—').toUpperCase()} — ${c.rec.cliente}</span>
        </div>`).join('');
      const pop=L.popup().setLatLng(latlng).setContent(div).openOn(map);
      div.querySelectorAll('button').forEach(b=>{
        b.onclick=()=>{ const c=cand[+b.dataset.i].rec; selectRoute(c,true); pop.remove(); };
      });
      return true;
    }

    /* ===================== MAPA (Canvas + anti-wrap) ===================== */
    function initMap(){
      map = L.map('map',{
        zoomControl:false, zoomSnap:0.25, zoomDelta:0.5, minZoom:3, maxZoom:20,
        preferCanvas:true, worldCopyJump:false, inertia:true
      }).setView([-5.5,-41.5],6);

      CANV = L.canvas({padding:0.5});

      L.control.zoom({position:'bottomright'}).addTo(map);
      BASE_LIGHT = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
        {attribution:'&copy; OpenStreetMap', crossOrigin:'anonymous'});
      BASE_DARK  = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png',
        {attribution:'&copy; Carto, OpenStreetMap', crossOrigin:'anonymous'});
      currentBase = BASE_LIGHT.addTo(map);

      const recalc=()=>{
        Object.values(CLIENT_LAYERS).forEach(g=>g.getLayers().forEach(l=>{ if(l.__recalc) l.__recalc(); }));
        if (HILAYER) HILAYER.getLayers().forEach(l=>{ if(l.__recalc) l.__recalc(); });
        if (SELAYER) SELAYER.getLayers().forEach(l=>{ if(l.__recalc) l.__recalc(); });
      };
      ['zoom','zoomend','moveend','viewreset','resize'].forEach(e=> map.on(e,recalc));

      map.on('click', e=>{
        if(e.originalEvent && e.originalEvent.altKey){
          showNearbyRoutes(e.latlng);
        }
      });
    }

    /* ===================== HELPERS ===================== */
    const rnd = v => Number(v).toFixed(5);
    const segKey = (a,b)=>{ const k1=rnd(a.lat)+','+rnd(a.lng), k2=rnd(b.lat)+','+rnd(b.lng); return (k1<k2)?(k1+'|'+k2):(k2+'|'+k1); };
    function getCoord(city){ const v=CITY_COORDS?.[city]; if(!v) return null; return Array.isArray(v)?{lat:+v[0],lng:+v[1]}:{lat:+v.lat,lng:+v.lng}; }
    function haversine(a,b){ const R=6371, toRad=d=>d*Math.PI/180; const dLat=toRad(b.lat-a.lat), dLng=toRad(b.lng-a.lng);
      const sa=Math.pow(Math.sin(dLat/2),2)+Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*Math.pow(Math.sin(dLng/2),2); return 2*R*Math.asin(Math.sqrt(sa)); }
    function totalKm(pts){ let s=0; for(let i=0;i<pts.length-1;i++) s+=haversine(pts[i],pts[i+1]); return s; }
    function uid(){ return Math.random().toString(36).slice(2,9); }

    function offsetLatLngs(base, offsets){
      const pts = base.map(ll => map.latLngToLayerPoint(ll));
      const dirs=[]; for(let i=0;i<pts.length-1;i++){ const d={x:pts[i+1].x-pts[i].x,y:pts[i+1].y-pts[i].y}; const m=Math.hypot(d.x,d.y)||1; dirs.push({x:d.x/m,y:d.y/m}); }
      const out=[];
      for(let i=0;i<pts.length;i++){
        const perp=v=>({x:-v.y,y:v.x});
        let n;
        if(i===0) n=perp(dirs[0]||{x:1,y:0});
        else if(i===pts.length-1) n=perp(dirs[dirs.length-1]||{x:1,y:0});
        else { const p1=perp(dirs[i-1]), p2=perp(dirs[i]); const sx=p1.x+p2.x, sy=p1.y+p2.y; const m=Math.hypot(sx,sy); n=(m<1e-6)?p2:{x:sx/m,y:sy/m}; }
        const o=offsets[i]||0; const p={x:pts[i].x+n.x*o, y:pts[i].y+n.y*o};
        out.push(map.layerPointToLatLng(p));
      }
      return out;
    }
    function makeOffsetPolyline(basePts, offsets, style){
      const ll=offsetLatLngs(basePts, offsets);
      const line=L.polyline(ll, Object.assign({renderer: CANV}, style));
      line.__base=basePts.slice(); line.__offs=offsets.slice();
      line.__recalc=function(){ this.setLatLngs(offsetLatLngs(this.__base,this.__offs)); };
      return line;
    }
    function computeOffsetsForPath(routeId, pts, SEG){
      if (OFFSET_MODE !== 'constant'){
        return pts.map((_,ix)=>{
          let acc=0,c=0;
          if(ix>0){ const s1=SEG.get(segKey(pts[ix-1],pts[ix]));   if(s1 && s1.cnt>1){ acc+=(s1.pos[routeId]-(s1.cnt-1)/2)*SHIFT_GAP; c++; } }
          if(ix<pts.length-1){ const s2=SEG.get(segKey(pts[ix],pts[ix+1])); if(s2 && s2.cnt>1){ acc+=(s2.pos[routeId]-(s2.cnt-1)/2)*SHIFT_GAP; c++; } }
          return c?acc/c:0;
        });
      }
      const positions=[], counts=[];
      for(let i=0;i<pts.length-1;i++){
        const s=SEG.get(segKey(pts[i],pts[i+1]));
        if (s && routeId in s.pos){ positions.push(s.pos[routeId]); counts.push(s.cnt); }
      }
      if (!positions.length) return new Array(pts.length).fill(0);
      const avgPos = positions.reduce((a,b)=>a+b,0)/positions.length;
      const maxCnt = Math.max.apply(null, counts);
      const idx = avgPos - (maxCnt - 1)/2;
      const base = idx * SHIFT_GAP;

      const n=pts.length, offs=new Array(n).fill(base);
      const taper=Math.min(3,Math.floor(n/3));
      for(let i=0;i<taper;i++){
        const f=(i+1)/(taper+1);
        offs[i]     *= f;
        offs[n-1-i] *= f;
      }
      return offs;
    }

    /* ===================== DESTAQUE / SELEÇÃO ===================== */
    function clearSelect(){ if(SELAYER){ SELAYER.remove(); SELAYER=null; } }
    function selectRoute(rec, center=false){
      clearSelect();
      SELAYER = L.layerGroup().addTo(map);
      const path = rec.line.getLatLngs();
      const shadow = L.polyline(path,{renderer:CANV, color:'#000', weight:18, opacity:0.25, lineCap:'round', lineJoin:'round'});
      const glow   = L.polyline(path,{renderer:CANV, color:'#ffd60a', weight:10, opacity:0.95, lineCap:'round', lineJoin:'round'});
      shadow.__base = rec.line.__base; shadow.__offs = rec.line.__offs; shadow.__recalc = rec.line.__recalc;
      glow.__base   = rec.line.__base; glow.__offs   = rec.line.__offs;   glow.__recalc   = rec.line.__recalc;
      shadow.addTo(SELAYER); glow.addTo(SELAYER);
      if(center){ map.fitBounds(L.latLngBounds(path).pad(0.08)); }
    }

    /* ===================== RENDER ===================== */
    function render(){
      if(!DATA?.clientes) return;
      Object.values(CLIENT_LAYERS).forEach(g=>g.remove()); CLIENT_LAYERS={};
      if(HILAYER){HILAYER.remove();HILAYER=null;} clearSelect(); ALL_LINES=[];

      const tipos=new Set(); if($('tProprio').checked)tipos.add('proprio'); if($('tCedido').checked)tipos.add('cedido'); if($('tRecebido').checked)tipos.add('recebido');

      const SEG=new Map();
      Object.entries(DATA.clientes).forEach(([cli,cfg])=>{
        if (CLIENT_VISIBLE[cli]===false) return;
        (cfg.canais||[]).forEach((canal,i)=>{
          if(!tipos.has((canal.tipo||'proprio').toLowerCase())) return;
          const pts=(canal.saltos||[]).map(getCoord).filter(Boolean);
          for(let k=0;k<pts.length-1;k++){
            const key=segKey(pts[k],pts[k+1]); const id=cli+'::'+(canal.id||String(i));
            const o=SEG.get(key)||{list:[],pos:{},cnt:0};
            if(!(id in o.pos)){ o.pos[id]=o.list.length; o.list.push(id); o.cnt=o.list.length; }
            SEG.set(key,o);
          }
        });
      });

      const box=$('legendClientsList'); box.innerHTML='';
      Object.keys(DATA.clientes).sort().forEach(cli=>{
        if(!(cli in CLIENT_VISIBLE)) CLIENT_VISIBLE[cli]=true;
        const color=DATA.clientes[cli]?.color||'#e11d48';
        const row=document.createElement('div'); row.className='row';
        row.innerHTML=`<input type="checkbox" ${CLIENT_VISIBLE[cli]?'checked':''} id="cli_${cli}">
                       <label for="cli_${cli}"><span class="sw" style="background:${color}"></span><span>${cli}</span></label>`;
        row.querySelector('input').onchange=e=>{ CLIENT_VISIBLE[cli]=e.target.checked; render(); };
        box.appendChild(row);
      });

      let bounds=[];
      Object.entries(DATA.clientes).forEach(([cli,cfg])=>{
        if (CLIENT_VISIBLE[cli]===false) return;
        const layer=L.layerGroup().addTo(map); CLIENT_LAYERS[cli]=layer;
        const color=cfg.color||'#e11d48';
        const showNodes = $('chkPontos').checked;

        (cfg.canais||[]).forEach((canal,i)=>{
          if(!tipos.has((canal.tipo||'proprio').toLowerCase())) return;
          const saltos=(canal.saltos||[]).filter(Boolean);
          const pts=saltos.map(getCoord).filter(Boolean);
          if(pts.length<2) return;

          const routeKey=cli+'::'+(canal.id||String(i));
          const offsets=computeOffsetsForPath(routeKey, pts, SEG);

          const dash=(canal.tipo||'').toLowerCase()==='cedido' ? '8 10'
                     :(canal.tipo||'').toLowerCase()==='recebido' ? '2 8' : null;
          const style={renderer:CANV, color, weight:4, opacity:.98, lineJoin:'round', dashArray:dash, lineCap:'round'};

          const distKm=totalKm(pts);
          const idEdit='e_'+uid(), idHi='h_'+uid(), idCtr='c_'+uid();
          const popupHtml=`<div>
            <b>${(canal.id||'—').toUpperCase()}</b><br>
            Cliente: <b>${cli}</b><br>
            Tipo: <b>${canal.tipo||'próprio'}</b><br>
            Capacidade: <b>${canal.capacidade||'—'}</b><br>
            Parceiro: <b>${canal.parceiro||'—'}</b><br>
            Distância total: <b>${distKm.toFixed(1)} km</b><br>
            Saltos: ${saltos.join(' → ')}<br>
            <div style="margin-top:6px; display:flex; gap:6px; flex-wrap:wrap">
              <button id="${idHi}">Destacar</button>
              <button id="${idCtr}">Centralizar percurso</button>
              <button id="${idEdit}">Editar canal</button>
            </div>
          </div>`;

          const line = makeOffsetPolyline(pts, offsets, style).addTo(layer).bindPopup(popupHtml);
          const hit  = makeOffsetPolyline(pts, offsets, {renderer:CANV, color:'#000', weight:30, opacity:0.001, lineJoin:'round', interactive:true})
                        .addTo(layer).bindPopup(popupHtml);

          const rec = { line, hit, cliente:cli, idx:i, canalRef:canal, pts, saltos,
                        text:(cli+' '+(canal.id||'')+' '+(canal.capacidade||'')+' '+(canal.tipo||'')+' '+(canal.parceiro||'')+' '+saltos.join(' ')).toLowerCase() };

          const attach = ()=>{
            const bE=document.getElementById(idEdit), bH=document.getElementById(idHi), bC=document.getElementById(idCtr);
            if(bE) bE.onclick=()=> openEditModal(cli,i);
            if(bH) bH.onclick=()=> selectRoute(rec,false);
            if(bC) bC.onclick=()=> selectRoute(rec,true);
          };
          line.on('popupopen', attach); hit.on('popupopen', attach);

          function routeClickHandler(ev){
            if (ev.originalEvent && ev.originalEvent.altKey){
              if (L && L.DomEvent) { L.DomEvent.stop(ev); }
              showNearbyRoutes(ev.latlng);
            } else {
              selectRoute(rec,false);
            }
          }
          line.on('click', routeClickHandler);
          hit.on('click',  routeClickHandler);

          ALL_LINES.push(rec);
          bounds.push(...pts);

          if (showNodes){
            const seen=new Set();
            saltos.forEach(s=>{
              if(seen.has(s)) return; seen.add(s);
              const c=getCoord(s); if(!c) return;
              L.circleMarker(c,{renderer:CANV, radius:4,weight:1,color:color,fillOpacity:.35})
               .addTo(layer)
               .bindTooltip(s, {sticky:true, direction:'top', offset:[0,-6], opacity:0.95});
            });
          }
        });
      });

      // ==> Enquadramento protegido por CITY_BOUNDS
      const b = bounds.length ? L.latLngBounds(bounds).pad(0.08) : CITY_BOUNDS;
      if (b) map.fitBounds(clampBoundsToCity(b));
    }

    /* ===================== BUSCA / HIGHLIGHT ===================== */
    function clearSelect(){ if(SELAYER){ SELAYER.remove(); SELAYER=null; } }
    function clearHighlight(){
      if(HILAYER){HILAYER.remove();HILAYER=null;}
      ALL_LINES.forEach(({line,hit})=>{ line.setStyle({opacity:0.98}); hit.setStyle({opacity:0.001}); });
    }
    function clearAllFocus(){ map.closePopup(); clearHighlight(); clearSelect(); }
    function highlight(q){
      clearHighlight(); const s=(q||'').trim().toLowerCase(); if(!s) return;
      HILAYER=L.layerGroup().addTo(map);
      ALL_LINES.forEach(r=>{
        const m=r.text.includes(s);
        r.line.setStyle({opacity: m ? 0.98 : 0.15});
        r.hit.setStyle({opacity:m?0.05:0.001});
        if(m) L.polyline(r.pts,{renderer:CANV, color:'#fffb00',weight:12,opacity:.35,interactive:false}).addTo(HILAYER);
      });
    }

    /* ===================== LOAD / EXPORT / CENTER ===================== */
    function normalizeJSON(json){
      const raw=json.CITY_COORDS||json.CITY||{}; const city={};
      Object.keys(raw).forEach(k=>{ const v=raw[k]; city[k]=Array.isArray(v)?{lat:+v[0],lng:+v[1]}:{lat:+v.lat,lng:+v.lng}; });
      let clientes=(json.DATA&&json.DATA.clientes)?json.DATA.clientes:json.clientes; if(!clientes&&json.DATA) clientes=json.DATA; if(!clientes) clientes={};
      return {city,clientes};
    }
    async function parseMaybe(txt){
      try{ return JSON.parse(txt); }
      catch(e){
        const s=document.createElement('script'); s.src='https://cdn.jsdelivr.net/npm/json5@2.2.3/dist/index.min.js';
        await new Promise((ok,ko)=>{ s.onload=ok; s.onerror=ko; document.head.appendChild(s); });
        return window.JSON5.parse(txt);
      }
    }
    function computeCityBounds(){
      const pts = Object.values(CITY_COORDS||{}).map(v=> Array.isArray(v)? L.latLng(+v[0],+v[1]) : L.latLng(+v.lat,+v.lng) );
      return pts.length ? L.latLngBounds(pts).pad(0.25) : null;
    }
    function clampBoundsToCity(b){
      if(!CITY_BOUNDS) return b;
      // se o centro do bounds não está perto do conjunto de cidades, volta para CITY_BOUNDS
      const c=b.getCenter(), ok = CITY_BOUNDS.pad(0.6).contains(c);
      return ok ? b : CITY_BOUNDS;
    }
    async function loadFromURL(){
      if (location.protocol==='file:'){
        alert('Abra o JSON pelo botão "Carregar JSON" (o navegador bloqueia fetch em file://).');
        return;
      }
      const txt=await fetch(JSON_URL+'?v='+Date.now(), {cache:'no-store'}).then(r=>r.text());
      const j=await parseMaybe(txt); const n=normalizeJSON(j);
      CITY_COORDS=n.city; DATA={clientes:n.clientes};
      Object.values(DATA.clientes||{}).forEach(c=>{ if(c?.color) registerUsedColor(c.color); });
      CITY_BOUNDS = computeCityBounds();
      if (CITY_BOUNDS) map.setMaxBounds(CITY_BOUNDS.pad(1.2)); // evita pular para outra cópia do mundo
      buildCityDatalist(); render();
    }
    function loadFromFile(file){
      const rd=new FileReader();
      rd.onload=async e=>{
        try{
          const j=await parseMaybe(e.target.result); const n=normalizeJSON(j);
          CITY_COORDS=n.city; DATA={clientes:n.clientes};
          Object.values(DATA.clientes||{}).forEach(c=>{ if(c?.color) registerUsedColor(c.color); });
          CITY_BOUNDS = computeCityBounds();
          if (CITY_BOUNDS) map.setMaxBounds(CITY_BOUNDS.pad(1.2));
          buildCityDatalist(); render();
        }catch(err){ alert('JSON inválido (remova vírgulas finais/comentários).'); }
      };
      rd.readAsText(file,'utf-8');
    }
    function buildCityDatalist(){
      const dl=$('citiesList'); dl.innerHTML='';
      Object.keys(CITY_COORDS||{}).sort().forEach(k=>{ const o=document.createElement('option'); o.value=k; dl.appendChild(o); });
    }

    function getRoutesBounds(){
      if(!ALL_LINES.length) return CITY_BOUNDS;
      let b=null;
      for(const rec of ALL_LINES){
        if(!rec.pts || rec.pts.length===0) continue;
        const lb=L.latLngBounds(rec.pts);
        b = b ? b.extend(lb) : L.latLngBounds(lb);
      }
      return b ? clampBoundsToCity(b) : CITY_BOUNDS;
    }
    function fitBoundsAsync(bounds,pad=0.06){
      if(!bounds) return Promise.resolve();
      return new Promise(res=>{
        let done=false; const fin=()=>{ if(!done){done=true;res();} };
        map.once('moveend', fin); setTimeout(fin, 450); map.fitBounds(bounds.pad(pad));
      });
    }
    function setViewAsync(center,zoom){
      return new Promise(res=>{
        let done=false; const fin=()=>{ if(!done){done=true;res();} };
        map.once('moveend', fin); setTimeout(fin, 450); map.setView(center, zoom);
      });
    }
    function waitTilesLoaded(timeoutMs = 1200){
      return new Promise(resolve=>{
        const layer = currentBase;
        if (!layer || !layer._map){ resolve(); return; }
        let done=false;
        const fin=()=>{ if(!done){done=true; resolve();} };
        if (!layer._loading){ fin(); return; }
        layer.once('load', fin);
        setTimeout(fin, timeoutMs);
      });
    }
    async function withFittedRoutesView(cb){
      const bounds=getRoutesBounds();
      const prev={center:map.getCenter(), zoom:map.getZoom()};
      if(bounds){
        await fitBoundsAsync(bounds, 0.06);
        await waitTilesLoaded();
        await new Promise(r=>setTimeout(r,120));
      }
      try{ return await cb(); }
      finally{
        if(bounds){
          await setViewAsync(prev.center, prev.zoom);
          await new Promise(r=>setTimeout(r,80));
        }
      }
    }
    function hideUI(hide){
      ['toolbar','legendClients'].forEach(id=>{ const el=$(id); if(el && el.style) el.style.visibility = hide?'hidden':'visible'; });
      document.querySelectorAll('.legend,.credit').forEach(el=> el.style.visibility = hide?'hidden':'visible');
    }

    async function exportPNG(){
      try{
        hideUI(true);
        const dataUrl = await withFittedRoutesView(async ()=>{
          return await new Promise((resolve, reject)=>{
            window.leafletImage(map, (err, canvas)=>{
              if(err) return reject(err);
              resolve(canvas.toDataURL('image/png'));
            });
          });
        });
        hideUI(false);
        const a=document.createElement('a'); a.href=dataUrl; a.download='mapadwdm.png'; a.click();
      }catch(e){ hideUI(false); alert('Falha ao exportar PNG: '+e.message); }
    }

    async function exportPDF(){
      try{
        hideUI(true);
        const dataUrl = await withFittedRoutesView(async ()=>{
          return await new Promise((resolve, reject)=>{
            window.leafletImage(map, (err, canvas)=>{
              if(err) return reject(err);
              resolve(canvas.toDataURL('image/jpeg', 0.92));
            });
          });
        });
        hideUI(false);
        const {jsPDF}=window.jspdf;
        const pdf=new jsPDF({orientation:'landscape',unit:'pt',format:'a3',compress:true});
        const W=pdf.internal.pageSize.getWidth(), H=pdf.internal.pageSize.getHeight(), M=24;
        const img=new Image(); await new Promise(r=>{ img.onload=r; img.src=dataUrl; });
        const w=W-2*M, h=w*img.height/img.width, x=M, y=(H-h)/2;
        pdf.addImage(dataUrl,'JPEG',x,y,w,h); pdf.save('mapadwdm.pdf');
      }catch(e){ hideUI(false); alert('Falha ao exportar PDF: '+e.message); }
    }

    /* ===================== UI (igual v11) ===================== */
    function initUI(){
      $('btnFetch').onclick = ()=> loadFromURL().catch(err=> alert('Erro carregando JSON: '+err.message));
      $('fileJSON').onchange = e=>{ if(e.target.files?.[0]) loadFromFile(e.target.files[0]); };
      ['tProprio','tCedido','tRecebido','chkPontos'].forEach(id=> $(id).onchange=render);
      $('chkDark').onchange = e=>{ map.removeLayer(currentBase); currentBase=(e.target.checked?BASE_DARK:BASE_LIGHT).addTo(map); };
      $('btnAllClients').onclick=()=>{ Object.keys(CLIENT_VISIBLE).forEach(k=> CLIENT_VISIBLE[k]=true); render(); };
      $('btnNoClients').onclick =()=>{ Object.keys(CLIENT_VISIBLE).forEach(k=> CLIENT_VISIBLE[k]=false); render(); };

      $('btnSearch').onclick = ()=> highlight($('txtSearch').value);
      $('btnClear').onclick  = ()=>{ $('txtSearch').value=''; clearAllFocus(); };
      $('txtSearch').onkeydown = e=>{
        if(e.key==='Enter'){ e.preventDefault(); highlight(e.target.value); }
        if(e.key==='Escape'){ clearAllFocus(); }
      };
      $('txtSearch').oninput   = e=>{ if(!e.target.value.trim()) clearHighlight(); };
      document.addEventListener('keydown', (e)=>{ if(e.key === 'Escape'){ clearAllFocus(); } });

      $('btnPng').onclick=exportPNG; $('btnPdf').onclick=exportPDF;
      $('btnExport').onclick=()=>{ if(!DATA||!CITY_COORDS){ alert('Nada para exportar ainda.'); return; }
        const blob=new Blob([JSON.stringify({CITY_COORDS,DATA},null,2)],{type:'application/json'}); const a=document.createElement('a');
        a.href=URL.createObjectURL(blob); a.download='mapadwdm_atualizado.json'; a.click(); URL.revokeObjectURL(a.href); };
      $('btnCenterMap').onclick=()=>{ const b=getRoutesBounds(); if(b) map.fitBounds(b.pad(0.08)); };

      // (os handlers de adicionar/editar/nova cidade continuam iguais à v11)
      // ...
    }

    /* ===================== BOOT ===================== */
    initMap();
    initUI();
    loadFromURL().catch(()=>{});
  })();
  </script>
</body>
</html>

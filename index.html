<!doctype html>
<html lang="pt-br">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mapa DWDM — v11-fix (parser tolerante)</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<!-- JSON5 para aceitar vírgulas finais, comentários, aspas simples etc. -->
<script src="https://cdn.jsdelivr.net/npm/json5@2.2.3/dist/index.min.js"></script>

<style>
  :root{ --bg:#f6f7fb; --fg:#111; --muted:#374151; --card:#fff; --bd:#e5e7eb; }
  body{margin:0;background:var(--bg);color:var(--fg);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;}
  #map{position:absolute; inset:0}

  .toolbar{position:absolute; z-index:1000; left:12px; top:12px; right:12px; display:flex; gap:10px; flex-wrap:wrap; align-items:center;
           background:var(--card); padding:10px 12px; border:1px solid var(--bd); border-radius:12px; box-shadow:0 6px 30px rgba(0,0,0,.06)}
  .toolbar .group{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .toolbar input[type="text"]{padding:7px 10px; border:1px solid var(--bd); border-radius:10px; min-width:260px}
  .toolbar button,.toolbar label.btn{padding:8px 10px; border:1px solid var(--bd); border-radius:10px; background:#fafafa; cursor:pointer}

  .legend,.legend-clients{position:absolute; right:14px; z-index:1000; background:var(--card); border:1px solid var(--bd); border-radius:10px; padding:8px 10px; color:#374151; font-size:12px}
  .legend{bottom:14px}
  .legend-clients{bottom:140px; max-height:300px; width:290px; overflow:auto}
  .legend .line{display:flex; align-items:center; gap:8px; margin:4px 0}
  .legend .sample{width:42px; height:0; border-top:3px solid #222}
  .legend .dash{border-top-style:dashed}
  .legend .dot{border-top-style:dotted; border-top-width:2px}

  .legend-clients .row{display:flex; align-items:center; gap:8px; padding:4px 0; border-bottom:1px dashed #eee}
  .legend-clients .sw{width:18px; height:12px; border-radius:3px; border:1px solid var(--bd)}
  .legend-clients .row label{display:flex; align-items:center; gap:8px; flex:1; cursor:pointer}

  .credit{position:absolute; left:14px; bottom:14px; z-index:1000; color:#374151; font-size:12px; background:var(--card);
          border:1px solid var(--bd); border-radius:10px; padding:6px 8px}

  .leaflet-control-container .leaflet-top,.leaflet-control-container .leaflet-bottom{z-index:1500}

  .modal{ position:fixed; inset:0; background:rgba(0,0,0,.3); display:none; align-items:center; justify-content:center; z-index:2000; }
  .modal .card{ background:var(--card); border:1px solid var(--bd); border-radius:12px; padding:16px; width:min(760px,96vw); box-shadow:0 10px 40px rgba(0,0,0,.15); }
  .modal .row{ display:flex; gap:10px; margin:8px 0; align-items:center; }
  .modal label{ width:170px; color:#374151; font-size:13px; }
  .modal input, .modal select{ flex:1; padding:8px; border:1px solid var(--bd); border-radius:8px; }

  .pillset{ display:flex; flex-wrap:wrap; gap:6px; }
  .pillset label{ border:1px solid var(--bd); border-radius:999px; padding:6px 10px; cursor:pointer; }
  .pillset input{ display:none; }
  .pillset input:checked + span{ background:#eef2ff; border-color:#c7d2fe; }

  .chips{ display:flex; gap:6px; flex-wrap:wrap; }
  .chip{ background:#eef2ff; border:1px solid #c7d2fe; border-radius:999px; padding:4px 8px; display:inline-flex; align-items:center; gap:6px; }
  .chip button{ border:0; background:transparent; cursor:pointer; font-weight:700; }
</style>
</head>
<body>
  <div id="map"></div>

  <div class="toolbar" id="toolbar">
    <div class="group">
      <button id="btnFetch">Recarregar JSON</button>
      <label class="btn">Carregar JSON <input id="fileJSON" type="file" accept=".json,.json5,.txt" hidden></label>
      <label><input type="checkbox" id="chkDark"> Tema escuro</label>
      <label><input type="checkbox" id="chkPontos" checked> Mostrar pontos</label>
      <button id="btnAdd">Adicionar canal</button>
      <button id="btnExport">Exportar JSON</button>
      <button id="btnPng">Exportar PNG</button>
      <button id="btnPdf">Exportar PDF</button>
      <button id="btnListPdf">Exportar Lista (PDF)</button>
      <button id="btnListXls">Exportar Lista (Excel)</button>
      <button id="btnCenterMap">Centralizar</button>
    </div>
    <div class="group" style="margin-left:auto">
      <input id="txtSearch" type="text" placeholder="buscar cliente/canal/cidade/parceiro"/>
      <button id="btnSearch">Buscar</button>
      <button id="btnClear">Limpar</button>
      <label><input type="checkbox" id="tProprio" checked> Próprio</label>
      <label><input type="checkbox" id="tCedido" checked> Cedido</label>
      <label><input type="checkbox" id="tRecebido" checked> Recebido</label>
    </div>
  </div>

  <div class="legend-clients" id="legendClients">
    <b>Clientes no mapa</b>
    <div style="display:flex;gap:8px;margin:6px 0">
      <button id="btnAllClients">Marcar todos</button>
      <button id="btnNoClients">Desmarcar todos</button>
    </div>
    <div id="legendClientsList"></div>
  </div>

  <div class="legend">
    <div class="line"><span class="sample"></span> Próprio — <i>linha contínua</i></div>
    <div class="line"><span class="sample dash"></span> Cedido — <i>linha tracejada</i></div>
    <div class="line"><span class="sample dot"></span> Recebido — <i>linha pontilhada</i></div>
  </div>
  <div class="credit">Afastamento automático nas rotas sobrepostas • Controles de zoom no canto inferior direito</div>

  <!-- Modais (Adicionar / Editar / Nova cidade) – mesmo conteúdo das versões anteriores -->
  <div class="modal" id="modalAdd">
    <div class="card">
      <h3 style="margin:0 0 8px 0;">Adicionar canal</h3>
      <div class="row"><label>Cliente</label><input id="addCliente" placeholder="ex.: NovoCliente"></div>
      <div class="row"><label>ID do canal</label><input id="addId" placeholder="ex.: DWDM-CH40-FORTALEZA<>NATAL"></div>
      <div class="row"><label>Tipo</label>
        <select id="addTipo">
          <option value="proprio">próprio</option>
          <option value="cedido">cedido</option>
          <option value="recebido">recebido</option>
        </select>
      </div>
      <div class="row"><label>Capacidade</label>
        <div class="pillset" id="addCaps">
          <label><input type="radio" name="addCap" value="100G" checked><span>100G</span></label>
          <label><input type="radio" name="addCap" value="200G"><span>200G</span></label>
          <label><input type="radio" name="addCap" value="300G"><span>300G</span></label>
          <label><input type="radio" name="addCap" value="400G"><span>400G</span></label>
          <label><input type="radio" name="addCap" value="600G"><span>600G</span></label>
          <label><input type="radio" name="addCap" value="800G"><span>800G</span></label>
        </div>
      </div>
      <div class="row"><label>Parceiro</label><input id="addParc" placeholder="habilita quando cedido/recebido" disabled></div>
      <div class="row"><label>Saltos</label>
        <div style="flex:1">
          <div class="chips" id="addSaltosChips"></div>
          <div style="display:flex; gap:8px; margin-top:6px;">
            <input id="addSaltosIn" list="citiesList" placeholder="digite uma cidade e Enter"/>
            <button id="btnAddSalto">Adicionar salto</button>
            <button id="btnAddCidade">Nova cidade</button>
          </div>
          <small style="color:#6b7280">Dica: cole “A > B > C” que eu quebro nos saltos.</small>
        </div>
      </div>
      <div class="actions" style="display:flex;justify-content:flex-end;gap:10px;margin-top:10px;">
        <button id="btnCancelAdd">Cancelar</button>
        <button id="btnSaveAdd">Salvar</button>
      </div>
      <div id="addWarn" style="color:#b91c1c; font-size:12px; margin-top:6px;"></div>
    </div>
  </div>

  <div class="modal" id="modalEdit">
    <div class="card">
      <h3 style="margin:0 0 8px 0;">Editar canal</h3>
      <div class="row"><label>Cliente</label><input id="editCliente" disabled></div>
      <div class="row"><label>ID do canal</label><input id="editId"></div>
      <div class="row"><label>Tipo</label>
        <select id="editTipo">
          <option value="proprio">próprio</option>
          <option value="cedido">cedido</option>
          <option value="recebido">recebido</option>
        </select>
      </div>
      <div class="row"><label>Capacidade</label>
        <div class="pillset" id="editCaps">
          <label><input type="radio" name="editCap" value="100G"><span>100G</span></label>
          <label><input type="radio" name="editCap" value="200G"><span>200G</span></label>
          <label><input type="radio" name="editCap" value="300G"><span>300G</span></label>
          <label><input type="radio" name="editCap" value="400G"><span>400G</span></label>
          <label><input type="radio" name="editCap" value="600G"><span>600G</span></label>
          <label><input type="radio" name="editCap" value="800G"><span>800G</span></label>
        </div>
      </div>
      <div class="row"><label>Parceiro</label><input id="editParc" placeholder="habilita quando cedido/recebido"></div>
      <div class="row"><label>Saltos</label>
        <div style="flex:1">
          <div class="chips" id="editSaltosChips"></div>
          <div style="display:flex; gap:8px; margin-top:6px;">
            <input id="editSaltosIn" list="citiesList" placeholder="digite uma cidade e Enter"/>
            <button id="btnEditAddSalto">Adicionar salto</button>
            <button id="btnEditAddCidade">Nova cidade</button>
          </div>
        </div>
      </div>
      <div class="actions" style="display:flex;justify-content:flex-end;gap:10px;margin-top:10px;">
        <button id="btnCancelEdit">Cancelar</button>
        <button id="btnSaveEdit">Salvar alterações</button>
      </div>
      <div id="editWarn" style="color:#b91c1c; font-size:12px; margin-top:6px;"></div>
    </div>
  </div>

  <div class="modal" id="modalCity">
    <div class="card">
      <h3 style="margin:0 0 8px 0;">Adicionar cidade</h3>
      <div class="row"><label>Nome da cidade</label><input id="cityName" placeholder="ex.: Floriano-PI"></div>
      <div class="row"><label>Latitude</label><input id="cityLat" placeholder="-6.7712"></div>
      <div class="row"><label>Longitude</label><input id="cityLng" placeholder="-43.0229"></div>
      <div class="actions" style="display:flex;justify-content:flex-end;gap:10px;margin-top:10px;">
        <button id="btnCancelCity">Cancelar</button>
        <button id="btnSaveCity">Salvar cidade</button>
      </div>
      <div id="cityWarn" style="color:#b91c1c; font-size:12px; margin-top:6px;"></div>
    </div>
  </div>

  <datalist id="citiesList"></datalist>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-image/leaflet-image.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <script>
  (function(){
    const JSON_URL  = 'mapadwdm.json';
    const SHIFT_GAP   = 12;
    const OFFSET_MODE = 'constant';

    let DATA=null, CITY_COORDS=null, CITY_BOUNDS=null;
    let map, BASE_LIGHT, BASE_DARK, currentBase, CANV;
    let CLIENT_LAYERS={}, HILAYER=null, SELAYER=null, ALL_LINES=[];
    let CLIENT_VISIBLE={};

    const $ = id => document.getElementById(id);

    /* =================== CORES BEM SEPARADAS =================== */
    const USED=[]; const MIN_DELTAE=28;
    function hexToRgb(hex){ const h=hex.replace('#','').trim(); const n=parseInt(h.length===3?h.split('').map(c=>c+c).join(''):h,16); return {r:(n>>16)&255,g:(n>>8)&255,b:n&255}; }
    function hslToRgb(h,s,l){ s/=100; l/=100; const C=(1-Math.abs(2*l-1))*s, hp=h/60, X=C*(1-Math.abs((hp%2)-1)); let r1=0,g1=0,b1=0;
      if(0<=hp&&hp<1){r1=C;g1=X;} else if(1<=hp&&hp<2){r1=X;g1=C;} else if(2<=hp&&hp<3){g1=C;b1=X;} else if(3<=hp&&hp<4){g1=X;b1=C;}
      else if(4<=hp&&hp<5){r1=X;b1=C;} else if(5<=hp&&hp<6){r1=C;b1=X;} const m=l-C/2; return {r:Math.round((r1+m)*255),g:Math.round((g1+m)*255),b:Math.round((b1+m)*255)}; }
    function rgbToXyz(r,g,b){ const sr=[r,g,b].map(v=>{ v/=255; return (v<=0.04045)? v/12.92 : Math.pow((v+0.055)/1.055,2.4); });
      return { x:(sr[0]*0.4124564+sr[1]*0.3575761+sr[2]*0.1804375)*100, y:(sr[0]*0.2126729+sr[1]*0.7151522+sr[2]*0.0721750)*100, z:(sr[0]*0.0193339+sr[1]*0.1191920+sr[2]*0.9503041)*100 }; }
    function xyzToLab(x,y,z){ const xr=x/95.047, yr=y/100, zr=z/108.883, f=t=>(t>0.008856?Math.cbrt(t):(7.787*t+16/116)); const fx=f(xr), fy=f(yr), fz=f(zr); return {L:(116*fy)-16, a:500*(fx-fy), b:200*(fy-fz)}; }
    function rgbToLab(r,g,b){ const xyz=rgbToXyz(r,g,b); return xyzToLab(xyz.x,xyz.y,xyz.z); }
    function deltaE00(l1,l2){
      const {L:L1,a:a1,b:b1}=l1,{L:L2,a:a2,b:b2}=l2;
      const avgLp=(L1+L2)/2, C1=Math.hypot(a1,b1), C2=Math.hypot(a2,b2), avgC=(C1+C2)/2;
      const G=0.5*(1-Math.sqrt(Math.pow(avgC,7)/(Math.pow(avgC,7)+Math.pow(25,7))));
      const a1p=(1+G)*a1, a2p=(1+G)*a2, C1p=Math.hypot(a1p,b1), C2p=Math.hypot(a2p,b2), avgCp=(C1p+C2p)/2;
      const h1p=(Math.atan2(b1,a1p)*180/Math.PI+360)%360, h2p=(Math.atan2(b2,a2p)*180/Math.PI+360)%360;
      let deltahp; if(Math.abs(h1p-h2p)<=180) deltahp=h2p-h1p; else deltahp=(h2p<=h1p)?h2p-h1p+360:h2p-h1p-360;
      const dHp=2*Math.sqrt(C1p*C2p)*Math.sin((deltahp/2)*Math.PI/180);
      const dLp=L2-L1, dCp=C2p-C1p; let avgHp; if(Math.abs(h1p-h2p)<=180) avgHp=(h1p+h2p)/2; else avgHp=(h1p+h2p+360)/2;
      const T=1-.17*Math.cos((avgHp-30)*Math.PI/180)+.24*Math.cos((2*avgHp)*Math.PI/180)+.32*Math.cos((3*avgHp+6)*Math.PI/180)-.2*Math.cos((4*avgHp-63)*Math.PI/180);
      const Sl=1+(0.015*Math.pow(avgLp-50,2))/Math.sqrt(20+Math.pow(avgLp-50,2)), Sc=1+.045*avgCp, Sh=1+.015*avgCp*T;
      const Rt=-2*Math.sqrt(Math.pow(avgCp,7)/(Math.pow(avgCp,7)+Math.pow(25,7)))*Math.sin((60*Math.exp(-Math.pow((avgHp-275)/25,2)))*Math.PI/180);
      return Math.sqrt(Math.pow(dLp/Sl,2)+Math.pow(dCp/Sc,2)+Math.pow(dHp/Sh,2)+Rt*(dCp/Sc)*(dHp/Sh));
    }
    function normalizeHex(x){ x=String(x||'').trim(); return x? (x.startsWith('#')?x.toLowerCase():'#'+x.toLowerCase()):null; }
    function registerUsedColor(hex){ const hx=normalizeHex(hex); if(!hx) return; const {r,g,b}=hexToRgb(hx); const lab=rgbToLab(r,g,b); if(!USED.some(u=>u.hex===hx)) USED.push({hex:hx,lab}); }
    function getOrCreateClientColor(n){
      n=(n||'').trim();
      if(DATA?.clientes?.[n]?.color){ const hx=normalizeHex(DATA.clientes[n].color); registerUsedColor(hx); return hx; }
      let hash=0; for(let i=0;i<n.length;i++) hash=(hash*31+n.charCodeAt(i))>>>0;
      let baseHue = hash % 360; const GOLD=137.508, SATS=[72,64,80], LIGHTS=[50,58,42];
      let best={hex:'#f0f', lab:null, score:-1};
      function hsl(h,s,l){ const {r,g,b}=hslToRgb(h,s,l); return '#'+[r,g,b].map(v=>v.toString(16).padStart(2,'0')).join(''); }
      for(let i=0;i<360;i++){
        const h=(baseHue + i*GOLD)%360;
        for(let sI=0;sI<SATS.length;sI++)
          for(let lI=0;lI<LIGHTS.length;lI++){
            const s=SATS[(sI+i)%SATS.length], l=LIGHTS[(lI+i)%LIGHTS.length];
            const {r,g,b}=hslToRgb(h,s,l); const lab=rgbToLab(r,g,b);
            let minD=Infinity; for(const u of USED){ const d=deltaE00(lab,u.lab); if(d<minD) minD=d; if(minD<MIN_DELTAE) break; }
            const hex=hsl(h,s,l);
            if(minD>=MIN_DELTAE){ registerUsedColor(hex); return hex; }
            if(minD>best.score) best={hex,lab,score:minD};
          }
      }
      registerUsedColor(best.hex); return best.hex;
    }

    /* =================== PROXIMIDADE (ALT) =================== */
    function pointSegDist(p, a, b){
      const abx=b.x-a.x, aby=b.y-a.y, apx=p.x-a.x, apy=p.y-a.y;
      const ab2=abx*abx+aby*aby; let t=ab2? (apx*abx+apy*aby)/ab2 : 0;
      if(t<0) t=0; else if(t>1) t=1;
      const x=a.x+abx*t, y=a.y+aby*t;
      return Math.hypot(p.x-x, p.y-y);
    }
    function routeMinDistPx(rec, latlng){
      const p=map.latLngToLayerPoint(latlng); const ll=rec.line.getLatLngs(); let min=Infinity;
      for(let i=0;i<ll.length-1;i++){ const a=map.latLngToLayerPoint(ll[i]), b=map.latLngToLayerPoint(ll[i+1]); min=Math.min(min, pointSegDist(p,a,b)); }
      return min;
    }
    function closestPointOnRouteLatLng(rec, latlng){
      const p = map.latLngToLayerPoint(latlng);
      const ll = rec.line.getLatLngs();
      let bestD = Infinity, bestPt = null;
      for(let i=0;i<ll.length-1;i++){
        const a = map.latLngToLayerPoint(ll[i]), b = map.latLngToLayerPoint(ll[i+1]);
        const abx=b.x-a.x, aby=b.y-a.y, apx=p.x-a.x, apy=p.y-a.y;
        const ab2=abx*abx+aby*aby; let t=ab2? (apx*abx+apy*aby)/ab2 : 0;
        if(t<0) t=0; else if(t>1) t=1;
        const x=a.x+abx*t, y=a.y+aby*t;
        const d=Math.hypot(p.x-x, p.y-y);
        if(d<bestD){ bestD=d; bestPt = map.layerPointToLatLng(L.point(x,y)); }
      }
      return bestPt || ll[Math.floor(ll.length/2)] || latlng;
    }


    function showNearbyRoutes(latlng){
      const cand=[]; for(const rec of ALL_LINES){ const d=routeMinDistPx(rec, latlng); if(d<=18) cand.push({rec,d}); }
      if(!cand.length) return false; cand.sort((a,b)=>a.d-b.d);
      const div=document.createElement('div');
      div.innerHTML='<b>Canais próximos</b><br>'+cand.slice(0,10).map((c,i)=>`
        <div style="margin:4px 0; display:flex; gap:6px; align-items:center">
          <span style="width:10px;height:10px;border-radius:50%;display:inline-block;background:${c.rec.line.options.color}"></span>
          <button data-i="${i}">Selecionar</button>
          <span>${(c.rec.canalRef.id||'—').toUpperCase()} — ${c.rec.cliente}</span>
        </div>`).join('');
      const pop=L.popup({closeOnEscapeKey:true}).setLatLng(latlng).setContent(div).openOn(map);
      let idx = 0;
      const buttons = ()=> Array.from(div.querySelectorAll('button'));
      const focusBtn = ()=>{ const arr=buttons(); if(arr[idx]) arr[idx].focus(); };
      setTimeout(focusBtn, 0);
      const closePop = ()=>{ try{ map.closePopup(pop); }catch(e){} };

      div.querySelectorAll('button').forEach(b=>{
        b.onclick=()=>{
          const c=cand[+b.dataset.i].rec;
          selectRoute(c,true);
          const where = (typeof closestPointOnRouteLatLng==='function') ? closestPointOnRouteLatLng(c, latlng) : latlng;
          openRoutePopupAt(c, where || latlng);
          closePop();
        };
      });
      // Keyboard navigation: ArrowUp/Down to move, Enter to choose, Esc to close
      const onKey = (ev)=>{
        const arr = buttons(); if (!arr.length) return;
        if (ev.key === 'ArrowDown'){ ev.preventDefault(); idx = (idx+1)%arr.length; focusBtn(); }
        else if (ev.key === 'ArrowUp'){ ev.preventDefault(); idx = (idx-1+arr.length)%arr.length; focusBtn(); }
        else if (ev.key === 'Enter'){ ev.preventDefault(); arr[idx].click(); }
        else if (ev.key === 'Escape'){ ev.preventDefault(); closePop(); document.removeEventListener('keydown', onKey); }
      };
      document.addEventListener('keydown', onKey, {once:false});
      map.once('click', ()=>{ closePop(); document.removeEventListener('keydown', onKey); });
      return true;
    }

    /* =================== MAPA =================== */
    function initMap(){
      map = L.map('map',{
        zoomControl:false, zoomSnap:0.25, zoomDelta:0.5, minZoom:3, maxZoom:20,
        preferCanvas:true, worldCopyJump:false, inertia:true
      }).setView([-5.5,-41.5],6);
      // Popup defaults to avoid ficar escondido sob a toolbar
      try{
        L.Popup.prototype.options.autoPan = true;
        L.Popup.prototype.options.keepInView = true;
        L.Popup.prototype.options.autoPanPaddingTopLeft = [20, 130];
        L.Popup.prototype.options.autoPanPadding = [24, 24];
      }catch(e){}
    

      CANV = L.canvas({padding:0.5});

      L.control.zoom({position:'bottomright'}).addTo(map);
      BASE_LIGHT = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
        {attribution:'&copy; OpenStreetMap', crossOrigin:'anonymous'});
      BASE_DARK  = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png',
        {attribution:'&copy; Carto, OpenStreetMap', crossOrigin:'anonymous'});
      currentBase = BASE_LIGHT.addTo(map);

      const recalc=()=>{
        Object.values(CLIENT_LAYERS).forEach(g=>g.getLayers().forEach(l=>{ if(l.__recalc) l.__recalc(); }));
        if (HILAYER) HILAYER.getLayers().forEach(l=>{ if(l.__recalc) l.__recalc(); });
        if (SELAYER) SELAYER.getLayers().forEach(l=>{ if(l.__recalc) l.__recalc(); });
      };
      ['zoom','zoomend','moveend','viewreset','resize'].forEach(e=> map.on(e,recalc));

      map.on('click', e=>{
        if(e.originalEvent && e.originalEvent.altKey){
          showNearbyRoutes(e.latlng);
        }
      });
    }

    /* =================== HELPERS =================== */

    function closeAllPopups(){
      try{ map.closePopup(); }catch(e){}
      try{
        if (Array.isArray(ALL_LINES)){
          ALL_LINES.forEach(r=>{
            try{ if(r.line && r.line.closePopup) r.line.closePopup(); }catch(e){}
            try{ if(r.hit  && r.hit.closePopup)  r.hit.closePopup();  }catch(e){}
          });
        }
      }catch(e){}
    }
    function openRoutePopupAt(rec, where){
      if (!rec || !rec.line) return;
      closeAllPopups();
      try{
        const p = rec.line.getPopup && rec.line.getPopup();
        if (p && p.options){
          p.options.autoPan = true;
          p.options.keepInView = true;
          if (!p.options.autoPanPaddingTopLeft) p.options.autoPanPaddingTopLeft = [20, 130];
          if (!p.options.autoPanPadding) p.options.autoPanPadding = [24, 24];
          if (!p.options.maxWidth) p.options.maxWidth = 420;
        }
      }catch(e){}
      try{ if (where) map.panTo(where, {animate:true}); }catch(e){}
      try{ rec.line.openPopup(where); }catch(e){}
    }
    
        const rnd = v => Number(v).toFixed(5);
    const segKey = (a,b)=>{ const k1=rnd(a.lat)+','+rnd(a.lng), k2=rnd(b.lat)+','+rnd(b.lng); return (k1<k2)?(k1+'|'+k2):(k2+'|'+k1); };
    function getCoord(city){ const v=CITY_COORDS?.[city]; if(!v) return null; return Array.isArray(v)?{lat:+v[0],lng:+v[1]}:{lat:+v.lat,lng:+v.lng}; }
    function haversine(a,b){ const R=6371, toRad=d=>d*Math.PI/180; const dLat=toRad(b.lat-a.lat), dLng=toRad(b.lng-a.lng);
      const sa=Math.pow(Math.sin(dLat/2),2)+Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*Math.pow(Math.sin(dLng/2),2); return 2*R*Math.asin(Math.sqrt(sa)); }
    function totalKm(pts){ let s=0; for(let i=0;i<pts.length-1;i++) s+=haversine(pts[i],pts[i+1]); return s; }
    function uid(){ return Math.random().toString(36).slice(2,9); }

    function offsetLatLngs(base, offsets){
      const pts = base.map(ll => map.latLngToLayerPoint(ll));
      const dirs=[]; for(let i=0;i<pts.length-1;i++){ const d={x:pts[i+1].x-pts[i].x,y:pts[i+1].y-pts[i].y}; const m=Math.hypot(d.x,d.y)||1; dirs.push({x:d.x/m,y:d.y/m}); }
      const out=[];
      for(let i=0;i<pts.length;i++){
        const perp=v=>({x:-v.y,y:v.x});
        let n;
        if(i===0) n=perp(dirs[0]||{x:1,y:0});
        else if(i===pts.length-1) n=perp(dirs[dirs.length-1]||{x:1,y:0});
        else { const p1=perp(dirs[i-1]), p2=perp(dirs[i]); const sx=p1.x+p2.x, sy=p1.y+p2.y; const m=Math.hypot(sx,sy); n=(m<1e-6)?p2:{x:sx/m,y:sy/m}; }
        const o=offsets[i]||0; const p={x:pts[i].x+n.x*o, y:pts[i].y+n.y*o};
        out.push(map.layerPointToLatLng(p));
      }
      return out;
    }
    function makeOffsetPolyline(basePts, offsets, style){
      const ll=offsetLatLngs(basePts, offsets);
      const line=L.polyline(ll, Object.assign({renderer: CANV}, style));
      line.__base=basePts.slice(); line.__offs=offsets.slice();
      line.__recalc=function(){ this.setLatLngs(offsetLatLngs(this.__base,this.__offs)); };
      return line;
    }
    function computeOffsetsForPath(routeId, pts, SEG){
      if (OFFSET_MODE !== 'constant'){
        return pts.map((_,ix)=>{
          let acc=0,c=0;
          if(ix>0){ const s1=SEG.get(segKey(pts[ix-1],pts[ix]));   if(s1 && s1.cnt>1){ acc+=(s1.pos[routeId]-(s1.cnt-1)/2)*SHIFT_GAP; c++; } }
          if(ix<pts.length-1){ const s2=SEG.get(segKey(pts[ix],pts[ix+1])); if(s2 && s2.cnt>1){ acc+=(s2.pos[routeId]-(s2.cnt-1)/2)*SHIFT_GAP; c++; } }
          return c?acc/c:0;
        });
      }
      const positions=[], counts=[];
      for(let i=0;i<pts.length-1;i++){
        const s=SEG.get(segKey(pts[i],pts[i+1]));
        if (s && routeId in s.pos){ positions.push(s.pos[routeId]); counts.push(s.cnt); }
      }
      if (!positions.length) return new Array(pts.length).fill(0);
      const avgPos = positions.reduce((a,b)=>a+b,0)/positions.length;
      const maxCnt = Math.max.apply(null, counts);
      const idx = avgPos - (maxCnt - 1)/2;
      const base = idx * SHIFT_GAP;

      const n=pts.length, offs=new Array(n).fill(base);
      const taper=Math.min(3,Math.floor(n/3));
      for(let i=0;i<taper;i++){
        const f=(i+1)/(taper+1);
        offs[i]     *= f;
        offs[n-1-i] *= f;
      }
      return offs;
    }

    /* =================== DESTAQUE / SELEÇÃO =================== */
    function clearSelect(){ if(SELAYER){ SELAYER.remove(); SELAYER=null; } }
    function selectRoute(rec, center=false){
      clearSelect();
      SELAYER = L.layerGroup().addTo(map);
      const path = rec.line.getLatLngs();
      const shadow = L.polyline(path,{renderer:CANV, color:'#000', weight:18, opacity:0.25, lineCap:'round', lineJoin:'round'});
      const glow   = L.polyline(path,{renderer:CANV, color:'#ffd60a', weight:10, opacity:0.95, lineCap:'round', lineJoin:'round'});
      shadow.__base = rec.line.__base; shadow.__offs = rec.line.__offs; shadow.__recalc = rec.line.__recalc;
      glow.__base   = rec.line.__base; glow.__offs   = rec.line.__offs;   glow.__recalc   = rec.line.__recalc;
      shadow.addTo(SELAYER); glow.addTo(SELAYER);
      if(center){ map.fitBounds(L.latLngBounds(path).pad(0.08)); }
    }

    /* =================== RENDER =================== */
    function render(){
      if(!DATA?.clientes) return;
      Object.values(CLIENT_LAYERS).forEach(g=>g.remove()); CLIENT_LAYERS={};
      if(HILAYER){HILAYER.remove();HILAYER=null;} clearSelect(); ALL_LINES=[];

      const tipos=new Set(); if($('tProprio').checked)tipos.add('proprio'); if($('tCedido').checked)tipos.add('cedido'); if($('tRecebido').checked)tipos.add('recebido');

      const SEG=new Map();
      Object.entries(DATA.clientes).forEach(([cli,cfg])=>{
        if (CLIENT_VISIBLE[cli]===false) return;
        (cfg.canais||[]).forEach((canal,i)=>{
          if(!tipos.has((canal.tipo||'proprio').toLowerCase())) return;
          const pts=(canal.saltos||[]).map(getCoord).filter(Boolean);
          for(let k=0;k<pts.length-1;k++){
            const key=segKey(pts[k],pts[k+1]); const id=cli+'::'+(canal.id||String(i));
            const o=SEG.get(key)||{list:[],pos:{},cnt:0};
            if(!(id in o.pos)){ o.pos[id]=o.list.length; o.list.push(id); o.cnt=o.list.length; }
            SEG.set(key,o);
          }
        });
      });

      const box=$('legendClientsList'); box.innerHTML='';
      Object.keys(DATA.clientes).sort().forEach(cli=>{
        if(!(cli in CLIENT_VISIBLE)) CLIENT_VISIBLE[cli]=true;
        const color=DATA.clientes[cli]?.color||'#e11d48';
        const row=document.createElement('div'); row.className='row';
        row.innerHTML=`<input type="checkbox" ${CLIENT_VISIBLE[cli]?'checked':''} id="cli_${cli}">
                       <label for="cli_${cli}"><span class="sw" style="background:${color}"></span><span>${cli}</span></label>`;
        row.querySelector('input').onchange=e=>{ CLIENT_VISIBLE[cli]=e.target.checked; render(); };
        box.appendChild(row);
      });

      let bounds=[];
      Object.entries(DATA.clientes).forEach(([cli,cfg])=>{
        if (CLIENT_VISIBLE[cli]===false) return;
        const layer=L.layerGroup().addTo(map); CLIENT_LAYERS[cli]=layer;
        const color=cfg.color||'#e11d48';
        const showNodes = $('chkPontos').checked;

        (cfg.canais||[]).forEach((canal,i)=>{
          if(!tipos.has((canal.tipo||'proprio').toLowerCase())) return;
          const saltos=(canal.saltos||[]).filter(Boolean);
          const pts=saltos.map(getCoord).filter(Boolean);
          if(pts.length<2) return;

          const routeKey=cli+'::'+(canal.id||String(i));
          const offsets=computeOffsetsForPath(routeKey, pts, SEG);

          const dash=(canal.tipo||'').toLowerCase()==='cedido' ? '8 10'
                     :(canal.tipo||'').toLowerCase()==='recebido' ? '2 8' : null;
          const style={renderer:CANV, color, weight:4, opacity:.98, lineJoin:'round', dashArray:dash, lineCap:'round'};

          const distKm=totalKm(pts);
          const idEdit='e_'+uid(), idHi='h_'+uid(), idCtr='c_'+uid(), idDel='d_'+uid();
          const popupHtml=`<div>
            <b>${(canal.id||'—').toUpperCase()}</b><br>
            Cliente: <b>${cli}</b><br>
            Tipo: <b>${canal.tipo||'próprio'}</b><br>
            Capacidade: <b>${canal.capacidade||'—'}</b><br>
            Parceiro: <b>${canal.parceiro||'—'}</b><br>
            Distância total: <b>${distKm.toFixed(1)} km</b><br>
            Saltos: ${saltos.join(' → ')}<br>
            <div style="margin-top:6px; display:flex; gap:6px; flex-wrap:wrap">
              <button id="${idHi}">Destacar</button>
              <button id="${idCtr}">Centralizar percurso</button>
              <button id="${idEdit}">Editar canal</button>
              <button id="${idDel}" style="color:#b91c1c;border-color:#fca5a5;background:#fff5f5">Excluir</button>
            </div>
          </div>`;

          const line = makeOffsetPolyline(pts, offsets, style).addTo(layer).bindPopup(popupHtml);
          const hit  = makeOffsetPolyline(pts, offsets, {renderer:CANV, color:'#000', weight:30, opacity:0.001, lineJoin:'round', interactive:true})
                        .addTo(layer).bindPopup(popupHtml);

          const rec = { line, hit, cliente:cli, idx:i, canalRef:canal, pts, saltos,
                        text:(cli+' '+(canal.id||'')+' '+(canal.capacidade||'')+' '+(canal.tipo||'')+' '+(canal.parceiro||'')+' '+saltos.join(' ')).toLowerCase() };

          const attach = ()=>{
            const bE=document.getElementById(idEdit), bH=document.getElementById(idHi), bC=document.getElementById(idCtr), bD=document.getElementById(idDel);
            if(bE) bE.onclick=()=> window.openEditModal(rec.cliente, rec.idx);   // <-- FIX: usa função global
            if(bH) bH.onclick=()=> selectRoute(rec,false);
            if(bC) bC.onclick=()=> selectRoute(rec,true);
            if(bD) bD.onclick=()=> window.deleteCanal(rec.cliente, rec.idx);     // botão excluir
          };
          line.on('popupopen', attach); hit.on('popupopen', attach);

          function routeClickHandler(ev){
            if (ev.originalEvent && ev.originalEvent.altKey){
              if (L && L.DomEvent) { L.DomEvent.stop(ev); }
              showNearbyRoutes(ev.latlng);
            } else {
              selectRoute(rec,false);
            }
          }
          line.on('click', routeClickHandler);
          hit.on('click',  routeClickHandler);

          ALL_LINES.push(rec);
          bounds.push(...pts);

          if (showNodes){
            const seen=new Set();
            saltos.forEach(s=>{
              if(seen.has(s)) return; seen.add(s);
              const c=getCoord(s); if(!c) return;
              L.circleMarker(c,{renderer:CANV, radius:4,weight:1,color:color,fillOpacity:.35})
               .addTo(layer)
               .bindTooltip(s, {sticky:true, direction:'top', offset:[0,-6], opacity:0.95});
            });
          }
        });
      });

      const b = bounds.length ? L.latLngBounds(bounds).pad(0.08) : CITY_BOUNDS;
      if (b) map.fitBounds(clampBoundsToCity(b));
    }

    /* =================== BUSCA / HIGHLIGHT =================== */
    function clearHighlight(){
      if(HILAYER){HILAYER.remove();HILAYER=null;}
      ALL_LINES.forEach(({line,hit})=>{ line.setStyle({opacity:0.98}); hit.setStyle({opacity:0.001}); });
    }
    function clearAllFocus(){ map.closePopup(); clearHighlight(); clearSelect(); }
    function highlight(q){
      closeAllPopups();
      clearHighlight();
      const sRaw=(q||'').trim().toLowerCase();
      if(!sRaw) return;
      // Normalize accents/diacritics for robust matching
      const normalize = (str)=> (str||'').toLowerCase().normalize('NFD').replace(/\p{Diacritic}+/gu,'');
      const tokens = normalize(sRaw).split(/\s+/).filter(Boolean);
      HILAYER=L.layerGroup().addTo(map);
      const bounds = [];
      const matches = [];
      ALL_LINES.forEach(r=>{
        // Build normalized text for each record on the fly
        const tnorm = normalize(r.text);
        const m = tokens.every(tok => tnorm.includes(tok));
        r.line.setStyle({opacity: m ? 0.98 : 0.15});
        r.hit.setStyle({opacity: m ? 0.05 : 0.001});
        if(m){
          matches.push(r);
          const path = r.line.getLatLngs();
          if (path && path.length){
            try{ bounds.push(L.latLngBounds(path)); }catch(e){}
          }
          L.polyline(r.pts,{renderer:CANV, color:'#fffb00',weight:12,opacity:.35,interactive:false}).addTo(HILAYER);
        }
      });
      if (bounds.length){
        let B = bounds[0];
        for (let i=1;i<bounds.length;i++){ B = B.extend(bounds[i]); }
        try{ map.fitBounds(B.pad(0.12)); }catch(e){} closeAllPopups();
      }
      
      
// Open popup only after map finishes moving, avoids stale popups reappearing
if (matches.length === 1){
  const rec0 = matches[0];
  let opened = false;
  const openLater = ()=>{
    if (opened) return; opened = true;
    try{
      const path = rec0.line.getLatLngs();
      const mid  = path && path[Math.floor(path.length/2)];
      openRoutePopupAt(rec0, mid);
    }catch(e){}
  };
  if (bounds.length){
    map.once('moveend', openLater);
    setTimeout(openLater, 400); // fallback if no movement occurs
  } else {
    openLater();
  }
} else {
  // Ensure no stale popup after moving when multiple matches
  if (bounds.length){
    map.once('moveend', ()=> closeAllPopups());
  } else {
    closeAllPopups();
  }
}

      
    }

    /* =================== PARSER TOLERANTE (NOVO) =================== */
    function sanitizeJsonText(txt){
      txt = txt.replace(/^\uFEFF/, '');              // BOM
      txt = txt.replace(/\/\*[\s\S]*?\*\//g, '')     // /* ... */
               .replace(/(^|[^:])\/\/[^\n\r]*/g, '$1'); // // ...
      txt = txt.replace(/,\s*(?=[}\]])/g, '');       // vírgulas finais
      return txt;
    }
    async function parseMaybe(txt){
      try {
        return JSON.parse(sanitizeJsonText(txt));
      } catch(e1){
        try {
          return (window.JSON5 ? window.JSON5.parse(txt) : JSON.parse(sanitizeJsonText(txt)));
        } catch(e2){
          const msg = (e2 && e2.message) ? e2.message : (e1 && e1.message) || 'Formato inválido';
          throw new Error('JSON inválido: ' + msg);
        }
      }
    }

    /* =================== LOAD / EXPORT / CENTER =================== */
    function normalizeJSON(json){
      const raw=json.CITY_COORDS||json.CITY||{}; const city={};
      Object.keys(raw).forEach(k=>{ const v=raw[k]; city[k]=Array.isArray(v)?{lat:+v[0],lng:+v[1]}:{lat:+v.lat,lng:+v.lng}; });
      let clientes=(json.DATA&&json.DATA.clientes)?json.DATA.clientes:json.clientes;
      if(!clientes && json.DATA) clientes=json.DATA;
      return {city,clientes};
    }
    function computeCityBounds(){
      const pts = Object.values(CITY_COORDS||{}).map(v=> Array.isArray(v)? L.latLng(+v[0],+v[1]) : L.latLng(+v.lat,+v.lng) );
      return pts.length ? L.latLngBounds(pts).pad(0.25) : null;
    }
    function clampBoundsToCity(b){
      if(!CITY_BOUNDS) return b;
      const c=b.getCenter(), ok = CITY_BOUNDS.pad(0.6).contains(c);
      return ok ? b : CITY_BOUNDS;
    }

    async function loadFromURL(){
      try{
        if (location.protocol==='file:'){ alert('Abrindo do disco: use o botão "Carregar JSON" para selecionar o arquivo.'); return; }
        const resp = await fetch(JSON_URL+'?v='+Date.now(), {cache:'no-store'});
        if(!resp.ok){ alert(`Falha ao baixar ${JSON_URL} (HTTP ${resp.status}).`); return; }
        const txt = await resp.text();
        const j   = await parseMaybe(txt);
        const n   = normalizeJSON(j);
        if(!n.city || !n.clientes || !Object.keys(n.clientes).length){
          alert('JSON carregado, mas sem clientes. Verifique a estrutura (CITY_COORDS e DATA/clients).'); return;
        }
        CITY_COORDS=n.city; DATA={clientes:n.clientes};
        Object.values(DATA.clientes||{}).forEach(c=>{ if(c?.color) registerUsedColor(c.color); });
        CITY_BOUNDS = computeCityBounds(); if(CITY_BOUNDS) map.setMaxBounds(CITY_BOUNDS.pad(1.2));
        buildCityDatalist(); render();
      }catch(err){ console.error(err); alert('JSON inválido: '+(err && err.message ? err.message : err)); }
    }

    function loadFromFile(file){
      const rd=new FileReader();
      rd.onload=async e=>{
        try{
          const j=await parseMaybe(e.target.result);
          const n=normalizeJSON(j);
          if(!n.city || !n.clientes || !Object.keys(n.clientes).length){
            alert('Arquivo lido, mas não encontrei clientes. Verifique a estrutura do JSON.'); return;
          }
          CITY_COORDS=n.city; DATA={clientes:n.clientes};
          Object.values(DATA.clientes||{}).forEach(c=>{ if(c?.color) registerUsedColor(c.color); });
          CITY_BOUNDS = computeCityBounds(); if(CITY_BOUNDS) map.setMaxBounds(CITY_BOUNDS.pad(1.2));
          buildCityDatalist(); render();
        }catch(err){ console.error(err); alert('JSON inválido: '+(err && err.message ? err.message : err)); }
      };
      rd.readAsText(file,'utf-8');
    }

    function buildCityDatalist(){
      const dl=$('citiesList'); dl.innerHTML='';
      Object.keys(CITY_COORDS||{}).sort().forEach(k=>{ const o=document.createElement('option'); o.value=k; dl.appendChild(o); });
    }

    function getRoutesBounds(){
      if(!ALL_LINES.length) return CITY_BOUNDS;
      let b=null;
      for(const rec of ALL_LINES){
        if(!rec.pts || rec.pts.length===0) continue;
        const lb=L.latLngBounds(rec.pts);
        b = b ? b.extend(lb) : L.latLngBounds(lb);
      }
      return b ? clampBoundsToCity(b) : CITY_BOUNDS;
    }
    function fitBoundsAsync(bounds,pad=0.06){
      if(!bounds) return Promise.resolve();
      return new Promise(res=>{
        let done=false; const fin=()=>{ if(!done){done=true;res();} };
        map.once('moveend', fin); setTimeout(fin, 450); map.fitBounds(bounds.pad(pad));
      });
    }
    function setViewAsync(center,zoom){
      return new Promise(res=>{
        let done=false; const fin=()=>{ if(!done){done=true;res();} };
        map.once('moveend', fin); setTimeout(fin, 450); map.setView(center, zoom);
      });
    }
    function waitTilesLoaded(timeoutMs = 1200){
      return new Promise(resolve=>{
        const layer = currentBase;
        if (!layer || !layer._map){ resolve(); return; }
        let done=false;
        const fin=()=>{ if(!done){done=true; resolve();} };
        if (!layer._loading){ fin(); return; }
        layer.once('load', fin);
        setTimeout(fin, timeoutMs);
      });
    }
    async function withFittedRoutesView(cb){
      const bounds=getRoutesBounds();
      const prev={center:map.getCenter(), zoom:map.getZoom()};
      if(bounds){
        await fitBoundsAsync(bounds, 0.06);
        await waitTilesLoaded();
        await new Promise(r=>setTimeout(r,120));
      }
      try{ return await cb(); }
      finally{
        if(bounds){
          await setViewAsync(prev.center, prev.zoom);
          await new Promise(r=>setTimeout(r,80));
        }
      }
    }
    function hideUI(hide){
      ['toolbar','legendClients'].forEach(id=>{ const el=$(id); if(el && el.style) el.style.visibility = hide?'hidden':'visible'; });
      document.querySelectorAll('.legend,.credit').forEach(el=> el.style.visibility = hide?'hidden':'visible');
    }

    async function exportPNG(){
      try{
        hideUI(true);
        const dataUrl = await withFittedRoutesView(async ()=>{
          return await new Promise((resolve, reject)=>{
            window.leafletImage(map, (err, canvas)=>{
              if(err) return reject(err);
              resolve(canvas.toDataURL('image/png'));
            });
          });
        });
        hideUI(false);
        const a=document.createElement('a'); a.href=dataUrl; a.download='mapadwdm.png'; a.click();
      }catch(e){ hideUI(false); alert('Falha ao exportar PNG: '+e.message); }
    }
    async function exportPDF(){
      try{
        hideUI(true);
        const dataUrl = await withFittedRoutesView(async ()=>{
          return await new Promise((resolve, reject)=>{
            window.leafletImage(map, (err, canvas)=>{
              if(err) return reject(err);
              resolve(canvas.toDataURL('image/jpeg', 0.92));
            });
          });
        });
        hideUI(false);
        const {jsPDF}=window.jspdf;
        const pdf=new jsPDF({orientation:'landscape',unit:'pt',format:'a3',compress:true});
        const W=pdf.internal.pageSize.getWidth(), H=pdf.internal.pageSize.getHeight(), M=24;
        const img=new Image(); await new Promise(r=>{ img.onload=r; img.src=dataUrl; });
        const w=W-2*M, h=w*img.height/img.width, x=M, y=(H-h)/2;
        pdf.addImage(dataUrl,'JPEG',x,y,w,h); pdf.save('mapadwdm.pdf');
      }catch(e){ hideUI(false); alert('Falha ao exportar PDF: '+e.message); }
    }
    /* =================== EXPORTAR LISTA (PDF/EXCEL) =================== */
    function buildChannelRows(){
      const rows = [];
      // Normalize search tokens (if any)
      const qEl = $('txtSearch');
      const q = qEl ? (qEl.value||'').trim() : '';
      const normalize = (str)=> (str||'').toLowerCase().normalize('NFD').replace(/\p{Diacritic}+/gu,'');
      const tokens = normalize(q).split(/\s+/).filter(Boolean);

      // Prefer ALL_LINES (already filtered by cliente/tipos/visibilidade no render())
      if (Array.isArray(ALL_LINES) && ALL_LINES.length){
        for (const rec of ALL_LINES){
          // If there is a search, only include matches consistent with highlight()
          if (tokens.length){
            const tnorm = normalize(rec.text);
            const ok = tokens.every(tok => tnorm.includes(tok));
            if (!ok) continue;
          }
          const canal = rec.canalRef || {};
          const saltos = (rec.saltos||[]).slice();
          // distance along the rendered path
          let km = 0;
          try{
            const pts = (saltos||[]).map(getCoord).filter(Boolean);
            for(let i=0;i<pts.length-1;i++){ km += map.distance(pts[i], pts[i+1]) / 1000.0; }
          }catch(e){ km = 0; }
          rows.push({
            cliente: rec.cliente || '—',
            canal: (canal.id||'').toUpperCase(),
            tipo: (canal.tipo||'proprio'),
            capacidade: (canal.capacidade||'—'),
            parceiro: (canal.parceiro||'—'),
            distancia: km,
            saltos: saltos.join(' → ')
          });
        }
      } else {
        // Fallback: full DATA (shouldn't happen if render() ran)
        if(!DATA?.clientes) return rows;
        const distKm = (saltos)=>{
          try{
            let km = 0;
            const pts = (saltos||[]).map(getCoord).filter(Boolean);
            for(let i=0;i<pts.length-1;i++){ km += map.distance(pts[i], pts[i+1]) / 1000.0; }
            return km;
          }catch(e){ return 0; }
        };
        for (const [cliente, cfg] of Object.entries(DATA.clientes||{})){
          const canais = (cfg && cfg.canais) || [];
          for (const canal of canais){
            const saltos = (canal.saltos||[]).slice();
            const text = (cliente+' '+(canal.id||'')+' '+(canal.capacidade||'')+' '+(canal.tipo||'')+' '+(canal.parceiro||'')+' '+saltos.join(' ')).toLowerCase();
            if (tokens.length){
              const tnorm = normalize(text);
              const ok = tokens.every(tok => tnorm.includes(tok));
              if (!ok) continue;
            }
            rows.push({
              cliente: cliente || '—',
              canal: (canal.id||'').toUpperCase(),
              tipo: (canal.tipo||'proprio'),
              capacidade: (canal.capacidade||'—'),
              parceiro: (canal.parceiro||'—'),
              distancia: distKm(saltos),
              saltos: saltos.join(' → ')
            });
          }
        }
      }

      // stable sort by cliente then canal
      rows.sort((a,b)=> (a.cliente.localeCompare(b.cliente) || a.canal.localeCompare(b.canal)));
      return rows;
    }

    function exportListPDF(){
      const rows = buildChannelRows();
      if(!rows.length){ alert('Sem canais para exportar.'); return; }
      const {jsPDF}=window.jspdf;
      const pdf=new jsPDF({orientation:'landscape',unit:'pt',format:'a3',compress:true});
      const W=pdf.internal.pageSize.getWidth(), H=pdf.internal.pageSize.getHeight();
      const M=28;
      const CW = W - 2*M;

      // Column weights (sum ~= 1.0)
      const weights = {
        cliente:   0.12,
        canal:     0.24,   // mais largo
        tipo:      0.07,
        capacidade:0.08,
        parceiro:  0.12,
        distancia: 0.07,
        saltos:    0.30    // reduzido e com quebra
      };
      const cols = [
        {key:'cliente',   title:'Cliente',     w: Math.round(CW*weights.cliente)},
        {key:'canal',     title:'Canal',       w: Math.round(CW*weights.canal)},
        {key:'tipo',      title:'Tipo',        w: Math.round(CW*weights.tipo)},
        {key:'capacidade',title:'Capacidade',  w: Math.round(CW*weights.capacidade)},
        {key:'parceiro',  title:'Parceiro',    w: Math.round(CW*weights.parceiro)},
        {key:'distancia', title:'Dist. (km)',  w: Math.round(CW*weights.distancia)},
        {key:'saltos',    title:'Saltos',      w: CW - (Math.round(CW*(weights.cliente+weights.canal+weights.tipo+weights.capacidade+weights.parceiro+weights.distancia))) }
      ];

      // Title
      let y = M+16;
      pdf.setFont('helvetica','bold'); pdf.setFontSize(15);
      pdf.text('Lista de Canais DWDM', M, y); y += 14;
      pdf.setFont('helvetica','normal'); pdf.setFontSize(9.5);
      pdf.text('Gerado em: '+new Date().toLocaleString(), M, y); y += 10;

      const drawHeader = () => {
        y += 8;
        pdf.setFillColor(240); pdf.rect(M, y, CW, 20, 'F');
        pdf.setFont('helvetica','bold'); pdf.setFontSize(10.5);
        let x = M+6; const headerY = y+14;
        cols.forEach(c=>{ pdf.text(c.title, x, headerY); x += c.w; });
        y += 24;
        pdf.setFont('helvetica','normal'); pdf.setFontSize(9.5);
      };

      drawHeader();

      // Hyphen/space aware wrapper
      const wrap = (text, maxW) => {
        const clean = String(text||'').replace(/→/g,'->'); // better PDF compatibility
        const parts = clean.split(/(\s+|[-/_.])/); // keep delimiters
        const lines = [];
        let cur = '';
        const limit = maxW - 8;
        for (let i=0;i<parts.length;i++){
          const piece = parts[i];
          const test = cur ? (cur + piece) : piece;
          const w = pdf.getTextWidth(test);
          if (w > limit && cur){
            lines.push(cur.trim());
            cur = piece.trim();
            // very long token fallback: hard-slice
            if (pdf.getTextWidth(cur) > limit){
              let token = cur, acc='';
              for (let j=0;j<token.length;j++){
                const t = acc + token[j];
                if (pdf.getTextWidth(t) > limit){
                  lines.push(acc);
                  acc = token[j];
                } else {
                  acc = t;
                }
              }
              cur = acc;
            }
          } else {
            cur = test;
          }
        }
        if (cur.trim()) lines.push(cur.trim());
        return lines;
      };

      let zebra = false;
      const drawRow = (r) => {
        const vals = {
          cliente: r.cliente,
          canal:   r.canal,
          tipo:    String(r.tipo||'').toUpperCase(),
          capacidade: r.capacidade,
          parceiro: r.parceiro,
          distancia: (r.distancia||0).toFixed(1).replace('.',','),
          saltos:  r.saltos
        };

        // Prepare wrapped cells
        const cellLines = [
          [String(vals.cliente)],
          wrap(vals.canal, cols[1].w),
          [String(vals.tipo)],
          [String(vals.capacidade)],
          wrap(vals.parceiro, cols[4].w),
          [String(vals.distancia)],
          wrap(vals.saltos, cols[6].w)
        ];

        const lineH = 16;
        const nLines = Math.max(...cellLines.map(a=>a.length));
        const rowH = nLines*lineH + 6;

        // Page break with header repeat
        if (y + rowH + M > H){
          pdf.addPage();
          y = M+16;
          drawHeader();
        }

        // Zebra background
        if (zebra){ pdf.setFillColor(250); pdf.rect(M, y-2, CW, rowH, 'F'); }
        zebra = !zebra;

        // Draw text
        let x = M+6;
        for (let c=0;c<cols.length;c++){
          const segs = cellLines[c];
          for (let k=0;k<segs.length;k++){
            pdf.text(segs[k], x, y + (k*lineH));
          }
          x += cols[c].w;
        }
        y += rowH;
      };

      rows.forEach(drawRow);
      pdf.save('canais_dwdm_lista.pdf');
    }

    function exportListXLS(){
      const rows = buildChannelRows();
      if(!rows.length){ alert('Sem canais para exportar.'); return; }
      // Build an HTML table that Excel abre normalmente (.xls)
      const escape = (s)=> String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
      const headers = ['Cliente','Canal','Tipo','Capacidade','Parceiro','Dist. (km)','Saltos'];
      const trh = '<tr>' + headers.map(h=>'<th style=\"text-align:left\">'+h+'</th>').join('') + '</tr>';
      const trs = rows.map(r=>'<tr>' + [
        escape(r.cliente),
        escape(r.canal),
        escape(String(r.tipo||'').toUpperCase()),
        escape(r.capacidade),
        escape(r.parceiro),
        (r.distancia||0).toFixed(1).replace('.',','),
        escape(r.saltos)
      ].map(v=>'<td>'+v+'</td>').join('') + '</tr>').join('');
      const htmlTable = '<table border=\"1\">'+trh+trs+'</table>';
      const htmlDoc = '<html><head><meta charset=\"utf-8\"></head><body>'+htmlTable+'</body></html>';
      const blob = new Blob([htmlDoc], {type:'application/vnd.ms-excel'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'canais_dwdm_lista.xls';
      a.click();
      setTimeout(()=> URL.revokeObjectURL(a.href), 1000);
    }


    /* =================== UI =================== */
    function initUI(){
      $('btnFetch').onclick = ()=> loadFromURL();
      $('fileJSON').onchange = e=>{ if(e.target.files?.[0]) loadFromFile(e.target.files[0]); };
      ['tProprio','tCedido','tRecebido','chkPontos'].forEach(id=> $(id).onchange=render);
      $('chkDark').onchange = e=>{ map.removeLayer(currentBase); currentBase=(e.target.checked?BASE_DARK:BASE_LIGHT).addTo(map); };
      $('btnAllClients').onclick=()=>{ Object.keys(CLIENT_VISIBLE).forEach(k=> CLIENT_VISIBLE[k]=true); render(); };
      $('btnNoClients').onclick =()=>{ Object.keys(CLIENT_VISIBLE).forEach(k=> CLIENT_VISIBLE[k]=false); render(); };

      $('btnSearch').onclick = ()=> { closeAllPopups(); highlight($('txtSearch').value); };
      $('btnClear').onclick  = ()=>{ closeAllPopups(); $('txtSearch').value=''; clearAllFocus(); };
      $('txtSearch').onkeydown = e=>{
        if(e.key==='Enter'){ e.preventDefault(); closeAllPopups(); highlight(e.target.value); }
        if(e.key==='Escape'){ clearAllFocus(); }
      };
      $('txtSearch').oninput   = e=>{ if(!e.target.value.trim()) clearHighlight(); };
      document.addEventListener('keydown', (e)=>{ if(e.key === 'Escape'){ clearAllFocus(); } });
      // Shortcuts: '/' or Ctrl+K to focus the search box
      document.addEventListener('keydown', (e)=>{
        if (e.target && (e.target.tagName==='INPUT' || e.target.tagName==='TEXTAREA' || e.target.isContentEditable)) return;
        if (e.key === '/' || (e.ctrlKey && (e.key==='k' || e.key==='K')) ){
          e.preventDefault();
          const el = $('txtSearch'); if (el){ el.focus(); el.select(); }
        }
      });
    

      $('btnPng').onclick=exportPNG; $('btnPdf').onclick=exportPDF; $('btnListPdf').onclick=exportListPDF; $('btnListXls').onclick=exportListXLS;
      $('btnExport').onclick=()=>{ if(!DATA||!CITY_COORDS){ alert('Nada para exportar ainda.'); return; }
        const blob=new Blob([JSON.stringify({CITY_COORDS,DATA},null,2)],{type:'application/json'}); const a=document.createElement('a');
        a.href=URL.createObjectURL(blob); a.download='mapadwdm_atualizado.json'; a.click(); URL.revokeObjectURL(a.href); };
      $('btnCenterMap').onclick=()=>{ const b=getRoutesBounds(); if(b) map.fitBounds(b.pad(0.08)); };

      // atalhos dos modais (mesmo comportamento que você já tinha)
      const addChip=(ct,val)=>{ const d=document.createElement('span'); d.className='chip'; d.dataset.city=val;
        const b=document.createElement('button'); b.textContent='×'; b.onclick=()=>d.remove(); d.append(val,b); ct.appendChild(d); };
      const getChips=ct=> Array.from(ct.querySelectorAll('.chip')).map(x=>x.dataset.city);
      const chipsFromText=t=> t.split(/>|→|->|—|,|;|\n/).map(s=>s.trim()).filter(Boolean);

      function openCityModal(onSave){
        $('cityName').value=''; $('cityLat').value=''; $('cityLng').value=''; $('cityWarn').textContent='';
        $('modalCity').style.display='flex';
        $('btnCancelCity').onclick=()=> $('modalCity').style.display='none';
        $('btnSaveCity').onclick=()=>{
          const name=$('cityName').value.trim(); const lat=parseFloat($('cityLat').value.trim()); const lng=parseFloat($('cityLng').value.trim());
          if(!name||isNaN(lat)||isNaN(lng)){ $('cityWarn').textContent='Preencha nome, latitude e longitude válidos.'; return; }
          if(!CITY_COORDS) CITY_COORDS={}; CITY_COORDS[name]={lat,lng}; buildCityDatalist();
          $('modalCity').style.display='none'; if(onSave) onSave(name);
        };
      }

      function openAddModal(){
        $('addCliente').value=''; $('addId').value=''; $('addTipo').value='proprio';
        document.querySelectorAll('#addCaps input[type="radio"]').forEach((r,i)=> r.checked=(i===0));
        $('addParc').value=''; $('addParc').disabled=true; $('addSaltosChips').innerHTML=''; $('addSaltosIn').value=''; $('addWarn').textContent='';
        $('modalAdd').style.display='flex';
      }
      function closeAddModal(){ $('modalAdd').style.display='none'; }
      function saveAdd(){
        const cliente=$('addCliente').value.trim(); const id=$('addId').value.trim().toUpperCase(); const tipo=$('addTipo').value;
        const cap=(document.querySelector('#addCaps input:checked')||{}).value||''; const parc=$('addParc').value.trim();
        let saltos=getChips($('addSaltosChips')); if(!saltos.length) saltos=chipsFromText($('addSaltosIn').value);
        if(!cliente||!id||!saltos.length){ $('addWarn').textContent='Preencha Cliente, ID e Saltos.'; return; }
        const unknown=saltos.filter(c=>!getCoord(c)); if(unknown.length){ $('addWarn').textContent='Cidade(s) não encontrada(s): '+unknown.join(', '); return; }
        if(!DATA) DATA={clientes:{}}; if(!DATA.clientes) DATA.clientes={};
        if(!DATA.clientes[cliente]){
          const color = getOrCreateClientColor(cliente);
          DATA.clientes[cliente] = { color, canais: [] };
        } else {
          if (DATA.clientes[cliente].color) registerUsedColor(DATA.clientes[cliente].color);
        }
        DATA.clientes[cliente].canais.push({id,tipo,capacidade:cap,parceiro:parc,saltos});
        closeAddModal(); render(); $('txtSearch').value=id; highlight(id);
      }

      /* ====== EDITAR / EXCLUIR: agora globais para uso no popup ====== */
      function openEditModal(cliente,idx){
        const canal=(DATA.clientes[cliente].canais||[])[idx]; if(!canal) return;
        $('editCliente').value=cliente; $('editId').value=(canal.id||'').toUpperCase(); $('editTipo').value=(canal.tipo||'proprio');
        document.querySelectorAll('#editCaps input[type="radio"]').forEach(r=> r.checked=(r.value===(canal.capacidade||'100G')));
        $('editParc').value=canal.parceiro||''; $('editParc').disabled=( $('editTipo').value==='proprio' );
        $('editSaltosChips').innerHTML=''; (canal.saltos||[]).forEach(s=> addChip($('editSaltosChips'), s));
        $('editSaltosIn').value=''; $('editWarn').textContent=''; $('modalEdit').style.display='flex';
        window.__lastEdit={cliente,idx};
      }
      function closeEditModal(){ $('modalEdit').style.display='none'; }
      function saveEdit(){
        const cliente=$('editCliente').value; const id=$('editId').value.trim().toUpperCase(); const tipo=$('editTipo').value;
        const cap=(document.querySelector('#editCaps input:checked')||{}).value||''; const parc=$('editParc').value.trim();
        const saltos=Array.from(document.querySelectorAll('#editSaltosChips .chip')).map(x=>x.dataset.city);
        if(!cliente||!id||!saltos.length){ $('editWarn').textContent='Preencha ID e Saltos.'; return; }
        const unknown=saltos.filter(c=>!getCoord(c)); if(unknown.length){ $('editWarn').textContent='Cidade(s) não encontrada(s): '+unknown.join(', '); return; }
        const i=(window.__lastEdit&&window.__lastEdit.cliente===cliente)?window.__lastEdit.idx:-1;
        if(i>=0 && DATA.clientes[cliente].canais[i]) DATA.clientes[cliente].canais[i]={id,tipo,capacidade:cap,parceiro:parc,saltos};
        closeEditModal(); render(); $('txtSearch').value=id; highlight(id);
      }
      function deleteCanal(cliente, idx){
        if(!DATA?.clientes?.[cliente]?.canais?.[idx]) return;
        const canal = DATA.clientes[cliente].canais[idx];
        const nome = canal?.id ? `“${canal.id}”` : 'este canal';
        if(confirm(`Excluir ${nome} do cliente ${cliente}?`)){
          DATA.clientes[cliente].canais.splice(idx,1);
          render();
          clearAllFocus();
        }
      }
      // expõe globalmente para o handler do popup
      window.openEditModal = openEditModal;
      window.deleteCanal   = deleteCanal;

      $('btnAdd').onclick=openAddModal; $('btnCancelAdd').onclick=closeAddModal; $('btnSaveAdd').onclick=saveAdd;
      $('addId').oninput=e=> e.target.value=e.target.value.toUpperCase();
      $('addTipo').onchange=e=>{ const own=e.target.value==='proprio'; $('addParc').disabled=own; if(own) $('addParc').value=''; };
      $('btnAddSalto').onclick=()=>{ const v=$('addSaltosIn').value.trim(); if(!v) return; addChip(document.getElementById('addSaltosChips'), v); $('addSaltosIn').value=''; };
      $('addSaltosIn').onkeydown=e=>{ if(e.key==='Enter'){ e.preventDefault(); $('btnAddSalto').click(); } };
      $('btnAddCidade').onclick=()=> openCityModal(name=> $('addSaltosIn').value=name);

      $('btnCancelEdit').onclick=closeEditModal; $('btnSaveEdit').onclick=saveEdit;
      $('editId').oninput=e=> e.target.value=e.target.value.toUpperCase();
      $('editTipo').onchange=e=>{ const own=e.target.value==='proprio'; $('editParc').disabled=own; if(own) $('editParc').value=''; };
      $('btnEditAddSalto').onclick=()=>{ const v=$('editSaltosIn').value.trim(); if(!v) return; addChip(document.getElementById('editSaltosChips'), v); $('editSaltosIn').value=''; };
      $('editSaltosIn').onkeydown=e=>{ if(e.key==='Enter'){ e.preventDefault(); $('btnEditAddSalto').click(); } };
      $('btnEditAddCidade').onclick=()=> openCityModal(name=> $('editSaltosIn').value=name);
    }

    /* =================== BOOT =================== */
    initMap();
    initUI();
    loadFromURL().catch(()=>{});
  })();
  </script>
</body>
</html>
